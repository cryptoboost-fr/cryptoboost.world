// üîç CRYPTOBOOST - V√âRIFICATION FINALE DES ERREURS
// Script complet pour d√©tecter toutes les erreurs restantes

class FinalErrorChecker {
    constructor() {
        this.errors = [];
        this.warnings = [];
        this.successes = [];
        this.startTime = Date.now();
    }

    async startCompleteCheck() {
        console.log('üîç CRYPTOBOOST - V√âRIFICATION FINALE DES ERREURS');
        console.log('=================================================');
        console.log(`‚è∞ D√©but: ${new Date().toLocaleString()}`);

        // Test 1: Erreurs JavaScript actives
        await this.checkActiveJavaScriptErrors();

        // Test 2: Erreurs de chargement
        await this.checkLoadingErrors();

        // Test 3: Erreurs fonctionnelles
        await this.checkFunctionalErrors();

        // Test 4: Erreurs de performance
        await this.checkPerformanceErrors();

        // Test 5: Erreurs de s√©curit√©
        await this.checkSecurityErrors();

        // Test 6: Erreurs d'accessibilit√©
        await this.checkAccessibilityErrors();

        // Rapport final
        this.generateFinalReport();
    }

    // Test 1: Erreurs JavaScript actives
    async checkActiveJavaScriptErrors() {
        console.log('\nüö® TEST 1: ERREURS JAVASCRIPT ACTIVES');

        const originalError = console.error;
        const originalWarn = console.warn;
        const errors = [];
        const warnings = [];

        console.error = (...args) => {
            errors.push(args.join(' '));
            originalError.apply(console, args);
        };

        console.warn = (...args) => {
            warnings.push(args.join(' '));
            originalWarn.apply(console, args);
        };

        // Simuler des interactions pour d√©clencher des erreurs
        await this.simulateUserInteractions();

        // Attendre que les erreurs se manifestent
        await new Promise(resolve => setTimeout(resolve, 2000));

        // Restaurer les fonctions originales
        console.error = originalError;
        console.warn = originalWarn;

        if (errors.length > 0) {
            this.errors.push({
                type: 'javascript_errors',
                count: errors.length,
                messages: errors.slice(0, 5),
                severity: 'high'
            });
            console.log(`‚ùå ${errors.length} erreurs JavaScript d√©tect√©es`);
            errors.slice(0, 3).forEach(error => {
                console.log(`   üî¥ ${error}`);
            });
        } else {
            this.successes.push('Aucune erreur JavaScript active');
            console.log('‚úÖ Aucune erreur JavaScript active');
        }

        if (warnings.length > 0) {
            this.warnings.push({
                type: 'javascript_warnings',
                count: warnings.length,
                messages: warnings.slice(0, 3)
            });
            console.log(`‚ö†Ô∏è ${warnings.length} avertissements JavaScript`);
        }
    }

    // Simuler des interactions utilisateur
    async simulateUserInteractions() {
        const interactions = [
            () => {
                // Test des fonctions critiques
                const functions = ['showLogin', 'showRegister', 'logout', 'validateAuth', 'showDashboard'];
                functions.forEach(func => {
                    if (typeof window[func] === 'function') {
                        try {
                            window[func]();
                        } catch (e) {
                            console.error(`Erreur dans ${func}:`, e);
                        }
                    }
                });
            },
            () => {
                // Test des √©l√©ments DOM
                const elements = ['loginModal', 'registerModal', 'dashboard'];
                elements.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        try {
                            element.style.display = 'none';
                            element.style.display = '';
                        } catch (e) {
                            console.error(`Erreur DOM ${id}:`, e);
                        }
                    }
                });
            },
            () => {
                // Test des appels API
                const apiCalls = [
                    fetch('/.netlify/functions/github-db?collection=users'),
                    fetch('/.netlify/functions/coinapi?action=rates&quote=EUR')
                ];

                apiCalls.forEach(async (call) => {
                    try {
                        await call;
                    } catch (e) {
                        console.error('Erreur API:', e);
                    }
                });
            }
        ];

        // Ex√©cuter les interactions
        for (const interaction of interactions) {
            try {
                interaction();
            } catch (e) {
                console.error('Erreur lors de l\'interaction:', e);
            }
        }
    }

    // Test 2: Erreurs de chargement
    async checkLoadingErrors() {
        console.log('\nüì¶ TEST 2: ERREURS DE CHARGEMENT');

        const resources = [
            { name: 'CSS Principal', url: '/styles.css', type: 'css' },
            { name: 'App JS', url: '/app.js', type: 'js' },
            { name: 'Auth JS', url: '/auth.js', type: 'js' },
            { name: 'Crypto API', url: '/crypto-api.js', type: 'js' },
            { name: 'Logo', url: '/assets/logo.svg', type: 'image' },
            { name: 'Favicon', url: '/favicon.ico', type: 'image' }
        ];

        let failedResources = 0;

        for (const resource of resources) {
            try {
                const response = await fetch(resource.url, { method: 'HEAD' });
                if (!response.ok) {
                    failedResources++;
                    this.errors.push({
                        type: 'resource_loading_error',
                        resource: resource.name,
                        url: resource.url,
                        status: response.status,
                        severity: resource.type === 'js' ? 'high' : 'medium'
                    });
                    console.log(`‚ùå ${resource.name}: ${response.status}`);
                } else {
                    console.log(`‚úÖ ${resource.name}: OK`);
                }
            } catch (error) {
                failedResources++;
                this.errors.push({
                    type: 'resource_network_error',
                    resource: resource.name,
                    url: resource.url,
                    error: error.message,
                    severity: 'high'
                });
                console.log(`‚ùå ${resource.name}: Erreur r√©seau`);
            }
        }

        if (failedResources === 0) {
            this.successes.push('Tous les assets charg√©s correctement');
        }
    }

    // Test 3: Erreurs fonctionnelles
    async checkFunctionalErrors() {
        console.log('\n‚öôÔ∏è TEST 3: ERREURS FONCTIONNELLES');

        // Test des fonctions critiques
        const criticalFunctions = [
            'showLogin', 'showRegister', 'logout', 'validateAuth',
            'showDashboard', 'showDeposit', 'showWithdraw', 'showExchange'
        ];

        let missingFunctions = 0;

        criticalFunctions.forEach(funcName => {
            if (typeof window[funcName] !== 'function') {
                missingFunctions++;
                this.errors.push({
                    type: 'missing_function',
                    function: funcName,
                    severity: 'high'
                });
                console.log(`‚ùå Fonction manquante: ${funcName}`);
            } else {
                console.log(`‚úÖ Fonction pr√©sente: ${funcName}`);
            }
        });

        if (missingFunctions === 0) {
            this.successes.push('Toutes les fonctions critiques pr√©sentes');
        }

        // Test des variables critiques
        const criticalVariables = ['app', 'auth', 'config', 'settings'];
        let missingVariables = 0;

        criticalVariables.forEach(varName => {
            if (typeof window[varName] === 'undefined') {
                missingVariables++;
                this.warnings.push({
                    type: 'missing_variable',
                    variable: varName,
                    severity: 'medium'
                });
                console.log(`‚ö†Ô∏è Variable manquante: ${varName}`);
            }
        });

        // Test des sections HTML
        const sections = ['stats', 'features', 'testimonials', 'faq', 'contact'];
        let missingSections = 0;

        sections.forEach(sectionId => {
            const section = document.getElementById(sectionId);
            if (!section) {
                missingSections++;
                this.warnings.push({
                    type: 'missing_section',
                    section: sectionId,
                    severity: 'low'
                });
                console.log(`‚ö†Ô∏è Section manquante: ${sectionId}`);
            }
        });

        if (missingSections === 0) {
            this.successes.push('Toutes les sections HTML pr√©sentes');
        }
    }

    // Test 4: Erreurs de performance
    async checkPerformanceErrors() {
        console.log('\n‚ö° TEST 4: ERREURS DE PERFORMANCE');

        // Test du temps de chargement
        if (performance.timing) {
            const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;
            const domTime = performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart;

            if (loadTime > 5000) {
                this.warnings.push({
                    type: 'slow_loading',
                    loadTime: loadTime,
                    severity: 'medium'
                });
                console.log(`‚ö†Ô∏è Temps de chargement lent: ${loadTime}ms`);
            } else {
                console.log(`‚úÖ Temps de chargement: ${loadTime}ms`);
            }

            if (domTime > 3000) {
                this.warnings.push({
                    type: 'slow_dom',
                    domTime: domTime,
                    severity: 'medium'
                });
                console.log(`‚ö†Ô∏è DOM lent: ${domTime}ms`);
            }
        }

        // Test de la taille DOM
        const domElements = document.querySelectorAll('*').length;
        if (domElements > 2000) {
            this.warnings.push({
                type: 'large_dom',
                elements: domElements,
                severity: 'medium'
            });
            console.log(`‚ö†Ô∏è DOM volumineux: ${domElements} √©l√©ments`);
        } else {
            console.log(`‚úÖ Taille DOM: ${domElements} √©l√©ments`);
        }

        // Test des images non optimis√©es
        const images = document.querySelectorAll('img');
        let unoptimizedImages = 0;

        images.forEach(img => {
            if (!img.hasAttribute('loading') && !img.hasAttribute('decoding')) {
                unoptimizedImages++;
            }
        });

        if (unoptimizedImages > 0) {
            this.warnings.push({
                type: 'unoptimized_images',
                count: unoptimizedImages,
                severity: 'low'
            });
            console.log(`‚ö†Ô∏è Images non optimis√©es: ${unoptimizedImages}`);
        }
    }

    // Test 5: Erreurs de s√©curit√©
    async checkSecurityErrors() {
        console.log('\nüîí TEST 5: ERREURS DE S√âCURIT√â');

        // Test HTTPS
        const isHTTPS = window.location.protocol === 'https:';
        if (!isHTTPS) {
            this.errors.push({
                type: 'no_https',
                severity: 'high'
            });
            console.log('‚ùå Pas de HTTPS');
        } else {
            console.log('‚úÖ HTTPS actif');
        }

        // Test du contenu mixte
        const html = document.documentElement.outerHTML;
        const hasMixedContent = html.includes('src="http://') || html.includes('href="http://');

        if (hasMixedContent) {
            this.errors.push({
                type: 'mixed_content',
                severity: 'high'
            });
            console.log('‚ùå Contenu mixte d√©tect√©');
        } else {
            console.log('‚úÖ Aucun contenu mixte');
        }

        // Test des headers de s√©curit√©
        try {
            const response = await fetch(window.location.href, { method: 'HEAD' });
            const headers = response.headers;

            const securityHeaders = [
                'x-frame-options',
                'x-content-type-options',
                'x-xss-protection'
            ];

            securityHeaders.forEach(header => {
                if (!headers.get(header)) {
                    this.warnings.push({
                        type: 'missing_security_header',
                        header: header,
                        severity: 'medium'
                    });
                    console.log(`‚ö†Ô∏è Header manquant: ${header}`);
                }
            });

            if (this.warnings.filter(w => w.type === 'missing_security_header').length === 0) {
                console.log('‚úÖ Headers de s√©curit√© pr√©sents');
            }

        } catch (error) {
            console.log('‚ö†Ô∏è Impossible de v√©rifier les headers');
        }
    }

    // Test 6: Erreurs d'accessibilit√©
    async checkAccessibilityErrors() {
        console.log('\n‚ôø TEST 6: ERREURS D\'ACCESSIBILIT√â');

        // Test des images sans alt
        const images = document.querySelectorAll('img');
        let imagesWithoutAlt = 0;

        images.forEach(img => {
            if (!img.hasAttribute('alt') || img.getAttribute('alt').trim() === '') {
                imagesWithoutAlt++;
            }
        });

        if (imagesWithoutAlt > 0) {
            this.warnings.push({
                type: 'missing_alt_text',
                count: imagesWithoutAlt,
                severity: 'medium'
            });
            console.log(`‚ö†Ô∏è Images sans alt text: ${imagesWithoutAlt}`);
        } else {
            console.log('‚úÖ Toutes les images ont un alt text');
        }

        // Test des liens sans texte
        const links = document.querySelectorAll('a');
        let linksWithoutText = 0;

        links.forEach(link => {
            const text = link.textContent.trim();
            if (!text && !link.querySelector('img')) {
                linksWithoutText++;
            }
        });

        if (linksWithoutText > 0) {
            this.warnings.push({
                type: 'empty_links',
                count: linksWithoutText,
                severity: 'medium'
            });
            console.log(`‚ö†Ô∏è Liens vides: ${linksWithoutText}`);
        }

        // Test du contraste (basique)
        const textElements = document.querySelectorAll('p, h1, h2, h3, h4, h5, h6');
        let lowContrastElements = 0;

        textElements.forEach(element => {
            try {
                const style = getComputedStyle(element);
                const color = style.color;
                const bgColor = style.backgroundColor;

                // V√©rification basique du contraste
                if (color === 'rgb(0, 0, 0)' && bgColor === 'rgba(0, 0, 0, 0)') {
                    lowContrastElements++;
                }
            } catch (e) {
                // Ignore les erreurs de calcul de style
            }
        });

        if (lowContrastElements > 0) {
            this.warnings.push({
                type: 'low_contrast',
                count: lowContrastElements,
                severity: 'low'
            });
            console.log(`‚ö†Ô∏è √âl√©ments √† faible contraste: ${lowContrastElements}`);
        } else {
            console.log('‚úÖ Contraste des √©l√©ments OK');
        }
    }

    // G√©n√©ration du rapport final
    generateFinalReport() {
        const duration = Date.now() - this.startTime;

        console.log('\n' + '='.repeat(80));
        console.log('üéØ RAPPORT FINAL - V√âRIFICATION DES ERREURS CRYPTOBOOST');
        console.log('='.repeat(80));

        // Statistiques g√©n√©rales
        const totalErrors = this.errors.length;
        const totalWarnings = this.warnings.length;
        const totalSuccesses = this.successes.length;

        console.log(`\nüìä STATISTIQUES G√âN√âRALES:`);
        console.log(`==========================`);
        console.log(`üö® Erreurs critiques: ${this.errors.filter(e => e.severity === 'high').length}`);
        console.log(`üü† Erreurs moyennes: ${this.errors.filter(e => e.severity === 'medium').length}`);
        console.log(`üü¢ Erreurs mineures: ${this.errors.filter(e => e.severity === 'low').length}`);
        console.log(`‚ö†Ô∏è Avertissements: ${totalWarnings}`);
        console.log(`‚úÖ Succ√®s: ${totalSuccesses}`);
        console.log(`‚è∞ Dur√©e du test: ${Math.round(duration/1000)}s`);

        // √âvaluation globale
        console.log(`\nüìã √âVALUATION GLOBALE:`);
        console.log(`=======================`);

        let overallScore = 100;
        let status = 'EXCELLENT';
        let recommendations = [];

        if (totalErrors > 0) {
            overallScore -= totalErrors * 15;
            recommendations.push('üö® Corriger les erreurs critiques d√©tect√©es');
        }

        if (totalWarnings > 5) {
            overallScore -= (totalWarnings - 5) * 5;
            recommendations.push('‚ö†Ô∏è Adresser les avertissements');
        }

        if (overallScore >= 90) {
            status = 'üéâ EXCELLENT';
            console.log(`${status} - Site parfait !`);
            console.log('   ‚úÖ Aucune erreur critique');
            console.log('   ‚úÖ Performance optimale');
            console.log('   ‚úÖ S√©curit√© assur√©e');
        } else if (overallScore >= 75) {
            status = 'üëç TR√àS BON';
            console.log(`${status} - Quelques am√©liorations mineures`);
            console.log('   ‚ö†Ô∏è Quelques probl√®mes √† corriger');
            console.log('   ‚úÖ Fonctionnalit√©s principales OK');
        } else if (overallScore >= 50) {
            status = '‚ö†Ô∏è MOYEN';
            console.log(`${status} - Corrections n√©cessaires`);
            console.log('   ‚ùå Probl√®mes d√©tect√©s n√©cessitant attention');
            console.log('   ‚úÖ Base fonctionnelle');
        } else {
            status = '‚ùå CRITIQUE';
            console.log(`${status} - Probl√®mes majeurs`);
            console.log('   üö® Corrections urgentes requises');
            console.log('   ‚ùå Fonctionnalit√©s d√©faillantes');
        }

        console.log(`\nüéØ SCORE GLOBAL: ${Math.max(0, overallScore)}%`);

        // D√©tail des erreurs
        if (this.errors.length > 0) {
            console.log(`\nüö® ERREURS D√âTECT√âES:`);
            console.log(`=====================`);

            this.errors.forEach((error, index) => {
                const severity = error.severity === 'high' ? 'üî¥' :
                               error.severity === 'medium' ? 'üü†' : 'üü¢';
                console.log(`${index + 1}. ${severity} ${error.type}`);

                if (error.resource) console.log(`   üìÅ Ressource: ${error.resource}`);
                if (error.function) console.log(`   üîß Fonction: ${error.function}`);
                if (error.variable) console.log(`   üì¶ Variable: ${error.variable}`);
                if (error.status) console.log(`   üìä Status: ${error.status}`);
                if (error.count) console.log(`   üî¢ Nombre: ${error.count}`);
            });
        }

        // D√©tail des avertissements
        if (this.warnings.length > 0) {
            console.log(`\n‚ö†Ô∏è AVERTISSEMENTS:`);
            console.log(`==================`);

            this.warnings.forEach((warning, index) => {
                const severity = warning.severity === 'high' ? 'üî¥' :
                               warning.severity === 'medium' ? 'üü†' : 'üü¢';
                console.log(`${index + 1}. ${severity} ${warning.type}`);

                if (warning.resource) console.log(`   üìÅ Ressource: ${warning.resource}`);
                if (warning.count) console.log(`   üî¢ Nombre: ${warning.count}`);
            });
        }

        // Succ√®s
        if (this.successes.length > 0) {
            console.log(`\n‚úÖ SUCC√àS:`);
            console.log(`===========`);

            this.successes.forEach((success, index) => {
                console.log(`${index + 1}. ‚úÖ ${success}`);
            });
        }

        // Recommandations
        if (recommendations.length > 0) {
            console.log(`\nüí° RECOMMANDATIONS:`);
            console.log(`===================`);

            recommendations.forEach((rec, index) => {
                console.log(`${index + 1}. ${rec}`);
            });
        }

        // R√©sum√© final
        console.log(`\nüìÖ R√âSUM√â:`);
        console.log(`==========`);
        console.log(`üåê Site test√©: ${window.location.href}`);
        console.log(`üìÖ Date: ${new Date().toLocaleString()}`);
        console.log(`üîß Navigateur: ${navigator.userAgent.split(' ').pop()}`);
        console.log(`üéØ √âtat: ${status} (${Math.max(0, overallScore)}%)`);

        console.log('\n' + '='.repeat(80));
        console.log('üèÅ V√âRIFICATION TERMIN√âE - CRYPTOBOOST DIAGNOSTIC');
        console.log('='.repeat(80));

        // Message final
        if (totalErrors === 0) {
            console.log('\nüéâ F√âLICITATIONS ! Aucun bug d√©tect√© !');
            console.log('   ‚úÖ Votre site CryptoBoost est parfait !');
        } else if (totalErrors <= 3) {
            console.log('\nüëç PRESQUE PARFAIT ! Quelques corrections mineures.');
            console.log('   üîß Utilisez les scripts de correction pour finaliser.');
        } else {
            console.log('\n‚ö†Ô∏è CORRECTIONS N√âCESSAIRES d√©tect√©es.');
            console.log('   üîß Appliquez les corrections recommand√©es.');
        }
    }

    // M√©thode statique pour d√©marrer
    static startCheck() {
        const checker = new FinalErrorChecker();
        checker.startCompleteCheck();
        return checker;
    }
}

// Auto-d√©marrage
if (typeof window !== 'undefined') {
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => FinalErrorChecker.startCheck(), 1000);
        });
    } else {
        setTimeout(() => FinalErrorChecker.startCheck(), 1000);
    }
}

console.log('üîç Error Checker charg√© et pr√™t !');
console.log('üìä Ce script va analyser toutes les erreurs potentielles...');
